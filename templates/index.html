<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes Pods</title>
    <link rel="stylesheet" href="static/styles.css">
</head>
<body>
    <div id="kubeconfig-upload" style="display: none;">
        <h2>Upload Kubeconfig File</h2>
        <input type="file" id="kubeconfig-file" accept=".yaml,.yml">
        <button onclick="uploadKubeconfig()">Upload</button>
    </div>

    <div id="main-content" style="display: none;">
        <h1>Kubernetes cluster info: <span id="clusterInfo"></span></h1>
        <!-- ... (rest of your existing HTML) ... -->
    </div>
    <h1>Kubernetes cluster info: <span id="clusterInfo"></span></h1>
    <h2>Persistent Volumes:</h2>
    <button id="togglePVsButton" onclick="togglePVs()">Show Persistent Volumes</button>
    <table id="pvsTable" style="display: none;">
        <thead>
            <tr>
                <th>Name</th>
                <th>Capacity</th>
                <th>PVC</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
    <table id="nodesTable" style="display: none;">
        <thead>
            <tr>
                <th>Name</th>
                <th>CPU</th>
                <th>Memory</th>
                <th>Node Info</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
    <button id="toggleButton" onclick="togglePods()">Get Pods</button>
    <select id="namespaceSelect" onchange="fetchPods()">
        <option value="default">default</option>
    </select>
    <table id="podsTable" style="display: none;">
        <thead>
            <tr>
                <th>Name</th>
                <th>Namespace</th>
                <th>Status</th>
                <th>IP</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>

    <script>
        let isExpanded = false;
        let isPVsVisible = false;

        function togglePVs() {
            const pvsTable = document.getElementById('pvsTable');
            const togglePVsButton = document.getElementById('togglePVsButton');

            if (isPVsVisible) {
                pvsTable.style.display = 'none';
                togglePVsButton.textContent = 'Show Persistent Volumes';
                isPVsVisible = false;
            } else {
                pvsTable.style.display = 'table';
                togglePVsButton.textContent = 'Hide Persistent Volumes';
                isPVsVisible = true;
            }
        }

        function togglePods() {
            const podsTable = document.getElementById('podsTable');
            const toggleButton = document.getElementById('toggleButton');

            if (isExpanded) {
                podsTable.style.display = 'none';
                toggleButton.textContent = 'Get Pods';
                isExpanded = false;
            } else {
                fetchPods();
                podsTable.style.display = 'table';
                toggleButton.textContent = 'Collapse Pod List';
                isExpanded = true;
            }
        }

        function fetchPods() {
            const namespace = document.getElementById('namespaceSelect').value;
            fetch(`/api/v1/namespaces/${namespace}/pods`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const podsTable = document.getElementById('podsTable').getElementsByTagName('tbody')[0];
                    podsTable.innerHTML = ''; // Clear existing rows
                    data.items.forEach(pod => {
                        const row = podsTable.insertRow();
                        const nameCell = row.insertCell(0);
                        const namespaceCell = row.insertCell(1);
                        const statusCell = row.insertCell(2);
                        const ipCell = row.insertCell(3);

                        const podLink = document.createElement('a');
                        podLink.href = `pod_description.html?namespace=${pod.namespace}&pod_name=${pod.name}`;
                        podLink.textContent = pod.name;

                        nameCell.appendChild(podLink);
                        namespaceCell.textContent = pod.namespace;
                        statusCell.textContent = pod.status;
                        ipCell.textContent = pod.ip;
                    });
                })
                .catch(error => console.error('Error fetching pods:', error));
        }

        function fetchClusterInfo() {
            fetch('/api/v1/cluster-info')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const clusterInfo = document.getElementById('clusterInfo');
                    clusterInfo.textContent = `Version: ${data.server_version}`;
                })
                .catch(error => console.error('Error fetching cluster info:', error));
        }

        function fetchNamespaces() {
            fetch('/api/v1/namespaces')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const namespaceSelect = document.getElementById('namespaceSelect');
                    data.items.forEach(ns => {
                        const option = document.createElement('option');
                        option.value = ns;
                        option.textContent = ns;
                        namespaceSelect.appendChild(option);
                    });
                })
                .catch(error => console.error('Error fetching namespaces:', error));
        }

        function fetchNodeInfo() {
            fetch('/api/v1/nodes')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    const nodesTable = document.getElementById('nodesTable').getElementsByTagName('tbody')[0];
                    nodesTable.innerHTML = ''; // Clear existing rows
                    data.items.forEach(node => {
                        const row = nodesTable.insertRow();
                        const nameCell = row.insertCell(0);
                        const cpuCell = row.insertCell(1);
                        const memoryCell = row.insertCell(2);
                        const nodeInfoCell = row.insertCell(3);

                        const cpu = node.capacity.cpu;
                        const memory = (parseInt(node.capacity.memory) / 1024 / 1024).toFixed(2) + ' MiB';
                        const nodeInfo = `OS: ${node.node_info.os_image}, Kernel: ${node.node_info.kernel_version}`;

                        nameCell.textContent = node.name;
                        cpuCell.textContent = cpu;
                        memoryCell.textContent = memory;
                        nodeInfoCell.textContent = nodeInfo;
                    });
                    document.getElementById('nodesTable').style.display = 'table';
                })
                .catch(error => console.error('Error fetching node info:', error));
        }

        function fetchPersistentVolumes() {
        fetch('/api/v1/persistentvolumes')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Fetched Persistent Volumes:', data); // Log the fetched data

                // Check if data.items exists and is an array
                if (!data.items || !Array.isArray(data.items)) {
                    console.error('Invalid data structure:', data);
                    return;
                }

                const pvsTable = document.getElementById('pvsTable').getElementsByTagName('tbody')[0];
                pvsTable.innerHTML = ''; // Clear existing rows

                data.items.forEach(pv => {
                    console.log('Processing PV:', pv); // Log each PV object

                    const row = pvsTable.insertRow();
                    const nameCell = row.insertCell(0);
                    const capacityCell = row.insertCell(1);
                    const pvcCell = row.insertCell(2);


                    nameCell.textContent = pv.name;
                    capacityCell.textContent = pv.capacity;
                    pvcCell.textContent = pv.pvc_name;

                    console.log('Added row:', { name: pv.name, capacity: pv.capacity, pvc: pv.pvc_name }); // Log each added row
                });

                // Display the table even if there are no items
                //document.getElementById('pvsTable').style.display = 'table';
            })
            .catch(error => {
                console.error('Error fetching persistent volumes:', error);
                // Optionally, display an error message in the UI
            });
    }

    function uploadKubeconfig() {
            const fileInput = document.getElementById('kubeconfig-file');
            const file = fileInput.files[0];
            if (file) {
                const formData = new FormData();
                formData.append('kubeconfig', file);

                fetch('/upload_kubeconfig', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                         sessionStorage.setItem('kubeconfigUploaded', 'true'); // Set flag in sessionStorage
                         document.getElementById('kubeconfig-upload').style.display = 'none';
                         document.getElementById('main-content').style.display = 'block';
                         loadKubernetesInfo();
                    } else {
                        alert('Failed to upload kubeconfig file');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('An error occurred while uploading the kubeconfig file');
                });
            }
        }

        function loadKubernetesInfo() {
            fetchClusterInfo();
            fetchNamespaces();
            fetchNodeInfo();
            fetchPersistentVolumes();
        }


        // Fetch cluster info, namespaces, node info, and persistent volumes on page load
        // window.onload = function() {
        //     fetchClusterInfo();
        //     fetchNamespaces();
        //     fetchNodeInfo();
        //     fetchPersistentVolumes();
        // };
        window.onload = function() {
            const kubeconfigUploaded = sessionStorage.getItem('kubeconfigUploaded');
            
            if (kubeconfigUploaded === 'true') {
                document.getElementById('main-content').style.display = 'block';
                loadKubernetesInfo();
            } else {
                document.getElementById('kubeconfig-upload').style.display = 'block';
            }
        };

    </script>
</body>
</html>